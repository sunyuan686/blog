<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/sunyuan686/blog</id><title>RSS feed of sunyuan686's blog</title><updated>2025-08-10T14:38:44.572569+00:00</updated><link href="https://github.com/sunyuan686/blog"/><link href="https://raw.githubusercontent.com/sunyuan686/blog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/sunyuan686/blog/issues/28</id><title>让 LLM 成为你的第二大脑：从入门到进阶的实战指南（基于 Karpathy《How I use LLMs》逐字稿）</title><updated>2025-08-10T14:38:45.110219+00:00</updated><content type="html"><![CDATA[<p>— 致谢：本文严格依据上述视频的逐字转录整理与重述，未引入未经视频验证的信息。<a href="https://youtu.be/EWvNQjAaOHw?si=BL2-ojFvG7aau-t5">How I use LLMs</a></p>
<b>
<p>TL;DR</p>
<ul>
<li>选对模型与“思考模式”（Thinking Models）是提效关键：简单任务用快模型，复杂推理换“思考”版本。</li>
<li>工具使用是 LLM 的“增幅器”：搜索、深研、代码执行、文件上下文、语音/图像/视频多模态显著拓展边界。</li>
<li>将 LLM 融入日常工作流：写作、编程、研究、可视化、记忆与个性化（自定义指令与 GPTs）都能系统提效。</li>
<li>框架化使用：明确任务→选模型→加工具→结构化输出→外部校验（高风险场景）→沉淀记忆与复用。</li>
<li>风险与常见坑：幻觉、过度信任、上下文管理混乱、成本不可控，需建立验证与成本监控机制。</li>
</ul>
<p>引言
大型语言模型（LLM）正以前所未有的速度渗入知识工作。Andrej Karpathy 在《How I use LLMs》中，以实操视角完整展示了他如何将 LLM 应用于检索、研究、编程、数据分析、多模态处理与个性化工作流中，并给出了“何时选何模型”“如何启用工具链”“如何把 LLM 嵌入日常生产力”的可复用方法论。本文严格基于该视频逐字稿内容，抽取核心路径，力求通俗但不牺牲严谨。</p>
<p>为什么重要</p>
<ul>
<li>从“聊天机器人”到“可编程工具链”：理解 LLM 的“模型选择 + 工具使用”范式，能直接改变工作方式。</li>
<li>从“临时问答”到“系统化工作流”：通过记忆、自定义与多模态，让你的知识工作具备可持续复用的“第二大脑”能力。</li>
<li>降低试错成本：本文提供可落地的决策框架与防坑清单，帮助你高效上手与进阶。</li>
</ul>
<h2>一、先认知生态：模型与层级能力</h2>
<ul>
<li>生态多元：OpenAI（ChatGPT/4 系列）、Anthropic（Claude）、Google（Gemini）、xAI（Grok）等提供不同能力与价格层级。</li>
<li>模型能力与价格：要“意识到你在用的模型”，不同梯度在语言理解、推理、多模态、速度和成本各异。</li>
<li>三段式训练观：预训练（知识）、后训练/指令微调（助理风格）、强化学习（发展“思考策略”）。</li>
<li>“思考模型”（Thinking Models）：在复杂数学、代码等任务上显著提升正确率，但输出更慢；日常问答不一定值得等待。</li>
</ul>
<p>常见坑</p>
<ul>
<li>只用一个“默认模型”：忽视任务-模型匹配，导致要么“杀鸡用牛刀”，要么性能不足。</li>
<li>追求“最强模型”而不控成本：忽略任务分层与混合策略带来的成本/延迟优化空间。</li>
</ul>
<h2>二、从基础互动到结构化任务</h2>
<ul>
<li>基础互动：清晰描述、给定上下文、要求结构化输出（如 JSON/要点/步骤），降低幻觉与歧义。</li>
<li>高效提问范式：指明角色/目标/约束/格式，必要时给样例，逐步式（step-by-step）分解任务。</li>
<li>结构化产出：把输出约束成“可验收对象”（要点、表格字段、代码块），便于后续自动化与复核。</li>
</ul>
<p>为什么重要</p>
<ul>
<li>把“对话”变成“协议”：明确输入输出与验收标准，才能把 LLM 稳定纳入流水线。</li>
</ul>
<h2>三、何时开启“思考模式”（Thinking models）</h2>
<ul>
<li>适用场景：数学推理、复杂代码、需要回溯/假设检验/多路径探索的问题。</li>
<li>使用策略：先尝试非思考模型（更快），若效果不佳再切换思考模型；不同提供商有显式开关（如 Grok 的“Think”）。</li>
</ul>
<p>常见坑</p>
<ul>
<li>为简单任务也启用“思考”，徒增等待与成本。</li>
</ul>
<h2>四、工具链：把 LLM 从“文本引擎”变成“工作引擎”</h2>
<p>H2 1. 网络搜索与“深度研究”</p>
<ul>
<li>即时搜索：在时效性、事实核验上，为模型接通互联网工具；要求引用来源与多源交叉验证。</li>
<li>深度研究（Deep Research）：搜索 + 归纳 + 长链思考，生成文档级综述与报告。</li>
</ul>
<p>为什么重要</p>
<ul>
<li>模型知识有“截止日期”；高风险事实必须“外部验证”。</li>
</ul>
<p>常见坑</p>
<ul>
<li>把搜索结果当权威，不做多源比对与引用审查。</li>
</ul>
<p>H2 2. 文件上下文与长文档处理</p>
<ul>
<li>上传文档作为上下文：让模型在你的材料上检索、摘要、抽取、比较。</li>
<li>让模型“先读后答”：先让模型产出逐段摘要，再汇总为全局结论，降低长文幻觉。</li>
</ul>
<p>H2 3. 代码执行与数据分析</p>
<ul>
<li>Python 工具/沙盒：用于计算、数据处理、绘图；把“可执行结果”与“语言解释”结合。</li>
<li>可视化：让模型一体化生成图表与解释，快速探索数据。</li>
</ul>
<p>常见坑</p>
<ul>
<li>仅凭自然语言“心算”高风险结论；不调用代码工具进行严谨计算与复核。</li>
</ul>
<p>H2 4. 多模态：语音、图像与视频</p>
<ul>
<li>语音输入/输出：口述草稿、转录访谈、生成有声内容；系统级转写工具可形成“随时记录—再总结”的工作流。</li>
<li>图像输入：OCR、表格截图抽取、图像理解与批注。</li>
<li>图像输出：草图到海报/草图到图标，辅以迭代说明优化视觉稿。</li>
<li>视频输入/输出：点选讲解、镜头级理解到摘要；新兴视频生成模型用于视觉原型。</li>
</ul>
<p>为什么重要</p>
<ul>
<li>把非结构化媒体“转译”为可搜索、可推理的文本/结构数据，打通信息流。</li>
</ul>
<h2>五、高级能力：记忆、指令与自定义 GPTs</h2>
<ul>
<li>记忆（Memory）：保存偏好、风格、上下文，减少重复说明，提高连续性。</li>
<li>自定义指令：为模型设置长期的角色与规范，让每次对话“开箱即用”。</li>
<li>自定义 GPTs：将特定工作流打包（指令+文件+工具），用于团队或个人复用。</li>
</ul>
<p>常见坑</p>
<ul>
<li>记忆内容堆砌、无治理：应定期维护、精炼，避免冲突与漂移。</li>
</ul>
<h2>六、成本与性能：理性治理</h2>
<ul>
<li>模型混用：把昂贵模型留给高价值环节，其他用轻量模型，必要时再升级。</li>
<li>Token 预算与结构化提示：减少冗余上下文，复用“摘要/提纲”代替全文灌注。</li>
<li>监控与告警：关注调用量、费用、延迟，建立预算与审计流程。</li>
</ul>
<p>常见坑</p>
<ul>
<li>不做监控：成本在暗中叠加；上下文不控导致响应变慢且更不稳。</li>
</ul>
<h2>七、把一切串成工作流：一套通用蓝图</h2>
<ul>
<li>
步骤化框架：<ol>
<li>明确目标与约束</li>
<li>选模型与是否启用“思考”</li>
<li>接入工具（搜索/代码/文件/多模态）</li>
<li>结构化输出与格式验收</li>
<li>外部验证（对高风险事实/计算/引述）</li>
<li>沉淀记忆与自定义工作流</li>
</ol>
</li>
<li>核心心法：用最小闭环快速迭代；必要时升级模型与工具；把成功范式打包复用。</li>
</ul>
<p>关键要点</p>
<ul>
<li>明确“任务—模型—工具”的三元匹配，别只用默认聊天范式。</li>
<li>对复杂推理再启用“思考模型”，优先保证速度与性价比。</li>
<li>工具是“能力放大器”：搜索、代码、文件上下文、多模态会成倍提升效果。</li>
<li>高风险输出必须外部验证，建立“证据链意识”与计算复核。</li>
<li>把成功对话固化为记忆/指令/自定义工作流，实现复用与可维护。</li>
</ul>
<p>行动清单</p>
<ul>
<li>建立你的模型选型表：按“任务类型—速度—成本—质量”归档可选模型。</li>
<li>为三类高频任务各写一个“结构化提示模板”（写作、研究、编程）。</li>
<li>打通三件工具：搜索核验、Python/数据分析、文件上下文（PDF/长文）。</li>
<li>设定“思考模型”开关的启用准则（何种难度/价值才切换）。</li>
<li>配置使用监控/预算告警，月度回顾一次“提示/上下文/模型搭配”的性价比。</li>
<li>建立“记忆与指令”基线文档，每两周精炼一次，移除冲突与冗余。</li>
<li>将稳定流程打包为自定义工作流或自定义 GPT，用于团队复用。</li>
</ul>
<p>致谢</p>
<ul>
<li>本文依据 Andrej Karpathy《How I use LLMs》视频逐字稿归纳整理，感谢其对 LLM 实用方法的系统讲解与示范。</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/28"/><category term="AI"/><published>2025-08-10T14:38:26+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/27</id><title>走近 LLM：用通俗语言理解 ChatGPT 背后的工作原理（基于 Karpathy「Deep Dive into LLMs」）</title><updated>2025-08-10T14:38:45.308375+00:00</updated><content type="html"><![CDATA[<p>— 致谢：本文严格依据上述视频的逐字转录整理与重述，未引入未经视频验证的信息。<a href="https://youtu.be/7xTGNNLPyMI?si=76Bd6bP4lkb-7ldT">Deep Dive into LLMs like ChatGPT</a></p>
<p>TL;DR(Too Long; Didn’t Read)</p>
<ul>
<li>LLM 的核心是“预测下一个token”的大型神经网络，通过互联网预训练与对话后训练逐步形成助理能力。</li>
<li>预训练学习通用知识，后训练用人类标注的对话数据“教出”助理式行为与拒答规范。</li>
<li>幻觉是系统性现象：模型会编造；通过工具使用（搜索、代码执行）与链式思考可显著降低错误。</li>
<li>“思考型模型”引入强化学习，在可验证任务上能涌现超越人类直觉的策略（类比 AlphaGo 的“第37手”）。</li>
<li>正确姿势：把 LLM 当“工具箱中的工具”，要验算、要分步、要用外部工具，不要盲信输出。</li>
</ul>
<p>当你在聊天框里敲下一个问题、回车，屏幕上出现的答案并不是魔法的低语。它更像是一位受过系统训练的专业“标注者”的统计学模拟：礼貌、 helpful、 truthful、 harmless。它擅长快速生成合理答案，却也会一本正经地胡说八道。理解它如何被训练、为何会出错、怎样让它更可靠，是把 AI 变成生产力而非不稳定因素的关键。</p>
<h2>1. LLM 是什么：一个“预测下一个词”的函数</h2>
<ul>
<li>定义（首次出现内联）：大语言模型（LLM, Large Language Model）是以“预测下一个 token（最小文本单位）”为目标训练的神经网络，可根据上下文生成文本。[</li>
<li>神经网络本质：输入 token 序列，经嵌入、注意力、前馈等层的固定数学表达，输出下一个 token 的概率分布；网络本身在推理时是无状态的“前向计算”，记忆来自上下文与参数中凝固的统计模式。</li>
<li>
为什么重要<ul>
<li>明确“预测”目标有助于理解它的优势（语言生成、类比）与局限（精确计算、计数、事实核验）。</li>
</ul>
</li>
<li>
常见坑<ul>
<li>把神经元类比为生物神经元，进而高估“内在意识”与“长期记忆”。LLM 的前向计算是短平快的统计变换。</li>
</ul>
</li>
</ul>
<h2>2. 训练一览：从预训练到后训练（Post-training）</h2>
<h3>2.1 预训练：吞下互联网，学习通用模式</h3>
<ul>
<li>数据目标：高质量、大规模、多样性互联网文本（如 FineWeb 同类），在数千台机器上训练数月，学习语言与世界的统计结构。</li>
<li>你可以把它看作：通过“看到大量文本”习得“语言常识与事实共识”。</li>
</ul>
<h3>2.2 后训练（对话对齐）：把“语言模型”调成“助理”</h3>
<ul>
<li>定义（内联）：后训练（post-training）指用人工构造的对话数据（多人回合、含人格、包含拒答规则）继续训练，使模型学会“助理式”行为。</li>
<li>数据如何来：公司编写详尽“标注说明”（helpful、truthful、harmless），雇佣专业标注者（含领域专家）为多样提示编写“理想回答”。</li>
<li>训练方式：在同一算法下短时间续训（可能仅数小时），用对话替换互联网数据，快速对齐模型的输出风格与价值观。</li>
<li>
为什么重要<ul>
<li>解释了“你在和谁对话”：统计上，你在和“受说明约束的人类标注者的平均模拟体”交流。</li>
</ul>
</li>
<li>
常见坑<ul>
<li>想象模型“查过资料后再回答”。实际多为统计拟合，特定事实未必核验，易引出幻觉。</li>
</ul>
</li>
</ul>
<h2>3. 推理与采样：答案不是唯一的</h2>
<ul>
<li>生成机制：给定前缀，模型输出各 token 概率；通过抽样（带温度、top-k/p 等）得到下一个 token，重复直到结束。</li>
<li>多样性来源：高概率 token 更常被采样，但不是唯一；同一问题可能出现多种合理表述。</li>
<li>
为什么重要<ul>
<li>提示工程（prompting）需控制采样策略；<strong>任务需要稳定时用更保守设置，创意写作可提高多样性。</strong></li>
</ul>
</li>
</ul>
<h2>4. LLM“心理学”：幻觉、工具使用与“需要 token 来思考”</h2>
<h3>4.1 幻觉（Hallucination）</h3>
<ul>
<li>定义（内联）：幻觉指模型无依据地编造事实、来源或细节。</li>
<li>成因：模型在“统计拟合”下补全高似然文本，并不等价于事实核验；特别在不可验证任务、长程逻辑与冷门事实上更易出错。</li>
<li>缓解策略：引入工具（检索、代码、计算器）、要求中间步（链式推理、草稿再定稿）、限制任务范围。</li>
</ul>
<h3>4.2 工具使用（Tool Use）</h3>
<ul>
<li>
实践要点：<ul>
<li>Web/检索：把事实核验外包给搜索/数据库，减少凭记忆回答。</li>
<li>代码解释器：让模型“写程序再求值”，比心算更可靠，适合数学、计数、解析结构化文本等。</li>
</ul>
</li>
<li>
为什么重要<ul>
<li>把复杂任务拆为可验证子任务，显著提升正确率与可审计性。</li>
</ul>
</li>
<li>
常见坑<ul>
<li>让模型一次性在“一个 token”内完成太多计算，导致错算、漏算；应要求逐步展开与外部求值。</li>
</ul>
</li>
</ul>
<h3>4.3 “模型需要 token 来思考”</h3>
<ul>
<li>直观理解：单次前向计算的“脑回路”有限，要求“一步到位”容易错；通过生成中间结果、分步推理、外部执行，给模型“更多 token 空间”来展开思路。</li>
<li>例：计数点位、长算式，直接回答易错；“use code”→ 将输入复制为字符串，用程序 count/计算，得到正确答案。</li>
</ul>
<h2>5. 从监督微调到强化学习：超越模仿，走向“思考型模型”</h2>
<h3>5.1 监督微调（SFT）与 RLHF</h3>
<ul>
<li>监督微调（内联）：用人类写的理想回答直接训练模型去模仿。</li>
<li>RLHF（内联）：人类先对多候选回答排序，训练“奖励模型”；再用强化学习优化模型，使其倾向“更被人偏好”的回答。</li>
</ul>
<h3>5.2 强化学习与“Move 37”时刻</h3>
<ul>
<li>类比 AlphaGo：通过自我博弈与奖励信号，探索超越人类经验分布的策略。出现“第37手”这类低人类概率但事后被证明精彩的着法。</li>
<li>对 LLM 的启示：在可验证的推理/数学等任务上，强化学习可能催生新颖推理策略，非单纯“标注者模拟”。</li>
<li>开放问题：在不可验证领域（如创意写作）中，“可转移的思考策略”能否泛化，仍在探索中。</li>
<li>
为什么重要<ul>
<li>指向“思考型模型”的方向：不仅模仿答案，更优化“思考过程”。</li>
</ul>
</li>
</ul>
<h2>6. 使用建议：把 LLM 当“会写草稿的助理”，而非“不会错的先知”</h2>
<h3>6.1 正确姿势</h3>
<ul>
<li>把问题拆小、逐步生成中间结果。</li>
<li>优先让模型使用工具（检索、代码执行），对关键结论做外部校验。</li>
<li>在可验证领域（编程、数学、数据处理）发挥其优势。</li>
</ul>
<h3>6.2 常见坑</h3>
<ul>
<li>盲信输出、不核验事实；让模型“心算大题”；一次性要求复杂推理与多跳事实链；忽视后训练价值观带来的“合理但无依据”表达。</li>
</ul>
<p>行动清单:</p>
<ul>
<li>设计 Prompt 时明确任务边界，要求“先思考后作答”，并允许中间结果输出。</li>
<li>对涉及事实/数值的内容，优先让模型使用检索或代码执行，再给出结论。</li>
<li>对长问题拆分子问题，逐段求解后再汇总。</li>
<li>在编程/数学/数据分析中，以“生成代码+运行校验”为默认流程。</li>
<li>对创意性任务，提升采样多样性；对精确任务，收紧采样并强制工具调用。</li>
</ul>
<p>致谢</p>
<ul>
<li>本文完全基于 Andrej Karpathy 视频“Deep Dive into LLMs like ChatGPT”之转录内容整理与重述，感谢其开放分享。</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/27"/><category term="AI"/><published>2025-08-10T14:21:59+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/26</id><title>macOS 下修复 Holmes 书签搜索插件：Chrome Manifest V3 兼容教程</title><updated>2025-08-10T14:38:45.501002+00:00</updated><content type="html"><![CDATA[<p>在新版 Chrome 中恢复被禁用的 Holmes 插件（Manifest V3 兼容）【Mac 教程】</p>
<blockquote>
<p>原插件名：<a href="https://chromewebstore.google.com/detail/holmes/gokficnebmomagijbakglkcmhdbchbhn"><strong>Holmes</strong></a>
插件功能：<strong>在 Chrome 地址栏中快速搜索书签</strong> Chrome Bookmark Search Extension
插件版本：<strong>3.3.1</strong>
错误提示：<code>This extension was turned off because it is no longer supported</code>
适用用户：插件被禁用，但希望继续使用的 Chrome 用户（macOS）</p>
</blockquote>
<p>
<img width="404" height="203" alt="Image" src="https://github.com/user-attachments/assets/db682b23-3f20-48f8-8c87-15ecf2a06267" />
<hr />
<h2>📌 背景介绍</h2>
<p>2025 年起，Google Chrome <strong>全面弃用 Manifest V2 插件</strong>，许多经典插件如 <strong>Holmes</strong> 被强制禁用，即使你在开发者模式中加载 <code>.crx</code> 或源码，也会提示不再支持。</p>
<hr />
<h2>🎯 本文目标</h2>
<ul>
<li>🛠️ 教你如何找到 Holmes 插件的本地源码</li>
<li>🧱 将插件升级为 Manifest V3</li>
<li>🔧 手动修复 <code>manifest.json</code> 及必要文件</li>
<li>✅ 成功加载并使用插件（兼容 Chrome 新版本）</li>
</ul>
<hr />
<h2>🖥️ 环境信息</h2>
<ul>
<li>系统：macOS</li>
<li>浏览器：Chrome Version 138.0.7204.184 (Official Build) (arm64)（禁用 Manifest V2 插件）</li>
<li>插件状态：被禁用，不再支持</li>
</ul>
<hr />
<h2>✅ 操作步骤</h2>
<h3>第一步：找到 Holmes 插件本地文件</h3>
<ol>
<li>
<p>打开 Finder，按下快捷键：</p>
<pre><code>Command + Shift + G
</code></pre>
</li>
<li>
<p>输入路径并回车：</p>
<pre><code>~/Library/Application Support/Google/Chrome/Default/Extensions/
</code></pre>
</li>
<li>
<p>找到 Holmes 插件的 ID 文件夹（Tab栏搜索: chrome://extensions/ 打开extensions页面）：</p>
</li>
</ol>
<p>找到Holmes对应的　ID,如</p>
<img width="1208" height="900" alt="Image" src="https://github.com/user-attachments/assets/52eb58e8-596a-4736-816d-6f7f2cbb3cfa" />
<pre><code>gokficnebmomagijbakglkcmhdbchbhn
</code></pre>
<ol start="4">
<li>
<p>打开 <code>3.3.1</code> 子目录：</p>
<pre><code>gokficnebmomagijbakglkcmhdbchbhn/3.3.1
</code></pre>
</li>
<li>
<p>将该文件夹复制到桌面或任意可写目录，如：</p>
<pre><code>~/Desktop/Holmes/
</code></pre>
</li>
</ol>
<hr />
<h3>第二步：重写 manifest.json 为 Manifest V3</h3>
<p>将原来的 <code>manifest.json</code> 替换为以下内容：</p>
<pre><code class="language-json">{
  &quot;manifest_version&quot;: 3,
  &quot;name&quot;: &quot;Holmes&quot;,
  &quot;version&quot;: &quot;3.3.1&quot;,
  &quot;description&quot;: &quot;Chrome Bookmark Search Extension&quot;,
  &quot;permissions&quot;: [&quot;bookmarks&quot;, &quot;tabs&quot;, &quot;storage&quot;],
  &quot;action&quot;: {
    &quot;default_icon&quot;: {
      &quot;16&quot;: &quot;images/icon_19.png&quot;,
      &quot;48&quot;: &quot;images/icon_48.png&quot;,
      &quot;128&quot;: &quot;images/icon_128.png&quot;
    },
    &quot;default_title&quot;: &quot;Holmes&quot;,
    &quot;default_popup&quot;: &quot;holmes.html&quot;
  },
  &quot;omnibox&quot;: {
    &quot;keyword&quot;: &quot;*&quot;
  },
  &quot;icons&quot;: {
    &quot;16&quot;: &quot;images/icon_19.png&quot;,
    &quot;48&quot;: &quot;images/icon_48.png&quot;,
    &quot;128&quot;: &quot;images/icon_128.png&quot;
  },
  &quot;commands&quot;: {
    &quot;_execute_action&quot;: {
      &quot;suggested_key&quot;: {
        &quot;default&quot;: &quot;Alt+Shift+H&quot;
      },
      &quot;description&quot;: &quot;Trigger Holmes popup&quot;
    }
  },
  &quot;host_permissions&quot;: [&quot;chrome://favicon/&quot;],
  &quot;content_security_policy&quot;: {
    &quot;extension_pages&quot;: &quot;script-src &#x27;self&#x27;; object-src &#x27;self&#x27;&quot;
  }
}
</code></pre>
<hr />
<h3>第三步：加载插件</h3>
<ol>
<li>
<p>打开 Chrome 地址栏，访问：</p>
<pre><code>chrome://extensions/
</code></pre>
</li>
<li>
<p>开启右上角的 <strong>开发者模式</strong></p>
</li>
<li>
<p>点击「加载已解压的扩展程序」</p>
</li>
<li>
<p>选择你刚刚修改好的 <code>~/Desktop/Holmes/3.3.1</code> 目录</p>
</li>
<li>
<p>若未报错，即表示成功</p>
</li>
</ol>
<hr />
<h2>🧪 插件测试方式</h2>
<ul>
<li>
<p>打开地址栏，输入：</p>
<pre><code>*空格（或者Tab键）要搜索的内容
</code></pre>
</li>
<li>
<p>插件会自动搜索你的书签内容，显示匹配结果</p>
</li>
<li>
<p>也可以点击扩展图标唤起 popup 页面（holmes.html）</p>
</li>
</ul>
<hr />
<hr />
<h2>✅ 成功复活插件</h2>
<img width="414" height="216" alt="Image" src="https://github.com/user-attachments/assets/46a0bc37-6aa5-4904-88a2-9f5fd6b51ea7" />
<img width="1187" height="214" alt="Image" src="https://github.com/user-attachments/assets/520efce5-588d-4457-bca8-0c158fe78fc2" />
<hr />
<hr />
<h2>🧠 总结</h2>
<p>即便 Google 强制禁用了 Manifest V2 扩展，我们依然可以通过手动方式：</p>
<ul>
<li>✅ 找回本地插件源码</li>
<li>✅ 升级 <code>manifest.json</code> 为 V3 格式</li>
<li>✅ 成功恢复插件功能</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/26"/><category term="TOOL &amp;&amp; RESOURCE"/><published>2025-08-07T05:09:37+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/25</id><title>通俗易懂理解AI 相关概念</title><updated>2025-08-10T14:38:45.684119+00:00</updated><content type="html"><![CDATA[<p>Agent: Agent 是一个能像人一样思考、决策并自动完成任务的智能程序。</p>
<pre><code class="language-python"># 简单AI Agent伪代码（聊天机器人示例）

# 1. 感知模块：获取用户输入
function get_user_input():
    user_input = read_from_interface()  # 从界面/终端读取文字
    return user_input

# 2. 大脑模块：处理输入并生成回复
function process_input(input):
    # 假设使用一个预训练模型或简单规则库
    if input contains &quot;你好&quot;:
        response = &quot;你好！有什么可以帮你的？&quot;
    else if input contains &quot;天气&quot;:
        response = query_weather_api()  # 调用外部API获取天气
    else:
        response = &quot;抱歉，我没听懂，能再说一遍吗？&quot;
    return response

# 3. 行动模块：执行回复
function take_action(response):
    send_to_interface(response)  # 将回复发送到界面/终端

# 4. 交互模块：主循环，管理用户交互
function main():
    while True:  # 持续运行
        # 感知：获取用户输入
        user_input = get_user_input()
        
        # 停止条件
        if user_input == &quot;退出&quot;:
            break
            
        # 大脑：处理输入，生成回复
        response = process_input(user_input)
        
        # 行动：输出回复
        take_action(response)

# 可选拓展：学习模块（简单示例）
function learn_from_feedback(user_input, user_feedback):
    if user_feedback == &quot;不好&quot;:
        update_knowledge_base(user_input, &quot;需要改进&quot;)  # 记录问题输入
    # 未来可加入模型微调或强化学习

# 启动Agent
main()
</code></pre>
<h3>说明</h3>
<ul>
<li><strong>感知</strong>：<code>get_user_input</code>模拟从界面获取用户输入。  </li>
<li><strong>大脑</strong>：<code>process_input</code>用简单条件语句模拟思考，实际可替换为AI模型（如LLM）。  </li>
<li><strong>行动</strong>：<code>take_action</code>将结果输出到界面。  </li>
<li><strong>交互</strong>：<code>main</code>循环让Agent持续与用户交互。  </li>
<li><strong>学习</strong>（拓展）：<code>learn_from_feedback</code>模拟通过反馈改进，实际可加入机器学习。  </li>
</ul>
<h3>拓展伪代码（复杂场景）</h3>
<p>如果要扩展为更复杂的Agent（比如任务规划Agent），可以加以下模块：</p>
<pre><code class="language-python"># 拓展：任务规划Agent伪代码
function plan_task(task):
    # 规划模块：分解任务
    subtasks = break_down_task(task)  # 拆分成小任务
    for subtask in subtasks:
        action = decide_action(subtask)  # 为每个小任务决定行动
        execute_action(action)  # 执行

# 感知：从环境获取多源数据
function get_environment_data():
    sensor_data = read_sensors()  # 比如摄像头、麦克风
    api_data = fetch_from_api()  # 外部数据
    return combine_data(sensor_data, api_data)

# 学习：通过经验优化
function optimize_model(experience):
    update_model_weights(experience)  # 使用强化学习或微调

# 主循环
function advanced_main():
    while True:
        data = get_environment_data()
        task = analyze_data(data)
        plan_task(task)
        optimize_model(get_experience())
</code></pre>
<p>MCP
先占个坑，近期要补充。</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/25"/><category term="TODO"/><published>2025-07-30T02:31:29+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/24</id><title>Jmeter 快速上手</title><updated>2025-08-10T14:38:45.859693+00:00</updated><content type="html"><![CDATA[<h1>JMeter 性能测试实战笔记</h1>
<p>本文档是一份详细的 JMeter 指南，涵盖了从创建测试计划、执行测试到解读性能结果的全过程。</p>
<h2>一、创建测试计划</h2>
<p>一个完整的测试计划是执行性能测试的基础。下面将分步介绍如何创建一个针对文件上传接口的测试场景。</p>
<h3><strong>第一步：添加线程组 (定义并发用户)</strong></h3>
<p>“线程组”是用来模拟并发用户的核心元件。它决定了有多少个“虚拟用户”同时去请求您的服务。</p>
<ol>
<li>在左侧的树状视图中，用鼠标<strong>右键点击</strong> <code>▲ Test Plan</code>。</li>
<li>在弹出的菜单中，依次选择 <code>添加 (Add)</code> -&gt; <code>线程 (Users)</code> -&gt; <code>线程组 (Thread Group)</code>。</li>
<li>
点击新创建的 <code>线程组</code>，您会在右侧看到它的配置选项。请按照如下计划来填写：<ul>
<li><strong>线程数 (Number of Threads)</strong>: <code>20</code> (模拟20个并发用户)</li>
<li><strong>Ramp-up Period (in seconds)</strong>: <code>10</code> (在10秒内让这20个用户全部启动)</li>
<li><strong>循环次数 (Loop Count)</strong>: <code>100</code> (每个用户重复请求100次)</li>
<li>也可以设置一段时间</li>
</ul>
</li>
</ol>
<img width="1434" height="785" alt="Image" src="https://github.com/user-attachments/assets/63411f08-65fb-4873-a523-fc76ecbd0d1d" />
<h3><strong>第二步：添加 HTTP 请求 (定义要测试的接口)</strong></h3>
<p>现在我们需要告诉 JMeter，这些虚拟用户具体要请求哪个接口。</p>
<ol>
<li>在左侧的树状视图中，<strong>右键点击</strong>您刚刚创建的 <code>线程组</code>。</li>
<li>依次选择 <code>添加 (Add)</code> -&gt; <code>取样器 (Sampler)</code> -&gt; <code>HTTP 请求 (HTTP Request)</code>。</li>
<li>
点击新创建的 <code>HTTP 请求</code>，在右侧面板中进行核心配置：<ul>
<li>
<strong>Web 服务器 (Web Server)</strong><ul>
<li><strong>服务器名称或IP (Server Name or IP)</strong>: <code>localhost</code></li>
<li><strong>端口号 (Port Number)</strong>: <code>8080</code></li>
</ul>
</li>
<li>
<strong>HTTP 请求 (HTTP Request)</strong><ul>
<li><strong>方法 (Method)</strong>: 选择 <code>POST</code></li>
<li><strong>路径 (Path)</strong>: <code>/api/convert/JODConverter</code></li>
<li><strong>重要</strong>: 如果要上传文件，记得勾选 <code>Use multipart/form-data for POST</code> 复选框。</li>
</ul>
</li>
</ul>
</li>
<li>
如果要<strong>配置上传文件</strong>:<ul>
<li>切换到下方的 <strong><code>Files Upload</code></strong> 标签页。</li>
<li>点击 <code>添加 (Add)</code> 按钮。</li>
<li>
填写文件信息：<ul>
<li><strong>文件路径 (File Path)</strong>: 点击 <code>Browse...</code> 选择您准备好的测试Word文档。</li>
<li><strong>参数名称 (Parameter Name)</strong>: <code>file</code> (必须和后端接口的 <code>@RequestParam(&quot;file&quot;)</code> 一致)</li>
<li><strong>MIME 类型 (MIME Type)</strong>: <code>application/vnd.openxmlformats-officedocument.wordprocessingml.document</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3><strong>第三步：添加监听器 (查看测试结果)</strong></h3>
<p>没有监听器，我们就看不到任何测试结果。</p>
<ol>
<li>再次<strong>右键点击</strong> <code>线程组</code>。</li>
<li>
依次选择 <code>添加 (Add)</code> -&gt; <code>监听器 (Listener)</code> -&gt; <code>聚合报告 (Aggregate Report)</code>。<ul>
<li>这个监听器会在测试运行时，以表格形式实时汇总和展示<strong>平均响应时间、吞吐量、错误率</strong>等核心性能指标。</li>
</ul>
</li>
<li>
(可选，推荐用于调试) <strong>右键点击</strong> <code>线程组</code> -&gt; <code>添加 (Add)</code> -&gt; <code>监听器 (Listener)</code> -&gt; <code>查看结果树 (View Results Tree)</code>。<ul>
<li>这个监听器可以看到每一次请求的详细信息。<strong>注意</strong>：在正式进行大并发量测试时，请<strong>禁用</strong>它（右键点击 -&gt; 禁用），因为它会消耗较多内存。</li>
</ul>
</li>
</ol>
<hr />
<h2>二、执行测试与保存结果</h2>
<p>测试计划创建好后，下一步就是执行它并保存结果以供分析。推荐使用命令行模式执行正式的压测。</p>
<h3><strong>方法一：通过 GUI 保存结果</strong></h3>
<p>此方法适用于快速查看和调试，不推荐用于正式压测。</p>
<ol>
<li><strong>在 JMeter 图形界面中，选中您的 <code>聚合报告 (Aggregate Report)</code> 监听器。</strong></li>
<li><strong>在右侧的配置面板中，找到 <code>文件名 (Filename)</code> 输入框。</strong></li>
<li><strong>点击 <code>浏览 (Browse)...</code> 按钮，选择一个路径并输入一个文件名</strong>，例如 <code>/Users/sunyuan/develop/project/word2pdf/performance_results/jmeter_results.csv</code>。 每次运行测试时，结果会自动追加到这个文件中。</li>
</ol>
<h3><strong>方法二：使用命令行执行压测（推荐的最佳实践）</strong></h3>
<p>虽然图形化界面便于设计脚本，但官方强烈建议使用<strong>命令行模式</strong>来执行真正的压力测试。这样做可以避免 GUI 带来的额外性能开销，确保测试结果的纯净和准确。</p>
<ol>
<li>
<p><strong>保存您的 JMeter 测试计划</strong>:</p>
<ul>
<li>在 JMeter 图形界面中，点击 <code>文件 (File)</code> -&gt; <code>保存测试计划为 (Save Test Plan as)</code>。</li>
<li>将测试计划保存为一个 <code>.jmx</code> 文件，例如 <code>/Users/sunyuan/develop/project/word2pdf/shell/test_plan.jmx</code>。</li>
</ul>
</li>
<li>
<p><strong>通过命令行执行</strong>:</p>
<ul>
<li>打开一个新的终端窗口。</li>
<li>使用以下命令来执行测试。这个命令会自动处理结果文件的保存和后续的 HTML 报告生成。</li>
</ul>
<p>Bash</p>
<pre><code># 定义变量，方便管理
BASE_DIR=&quot;/Users/sunyuan/develop/project/word2pdf&quot;
TEST_PLAN=&quot;${BASE_DIR}/shell/test_plan.jmx&quot;
RESULT_FILE=&quot;${BASE_DIR}/performance_results/jmeter_results.csv&quot;
REPORT_DIR=&quot;${BASE_DIR}/performance_results/html_report&quot;

# 确保结果文件和报告目录是干净的 (JMeter要求报告目录为空)
rm -f $RESULT_FILE
rm -rf $REPORT_DIR
mkdir -p $REPORT_DIR

# 执行 JMeter 命令行压测
jmeter -n -t $TEST_PLAN -l $RESULT_FILE -e -o $REPORT_DIR
</code></pre>
<p><strong>命令参数解析</strong>:</p>
<ul>
<li><code>-n</code>: <strong>n</strong>on-GUI mode，以无图形界面模式运行。</li>
<li><code>-t &lt;file.jmx&gt;</code>: <strong>t</strong>est plan，指定要运行的测试计划文件。</li>
<li><code>-l &lt;file.csv&gt;</code>: <strong>l</strong>og file，指定用于记录测试结果的日志文件。</li>
<li><code>-e</code>: <strong>e</strong>nd，表示在测试结束后生成 HTML 报告。</li>
<li><code>-o &lt;directory&gt;</code>: <strong>o</strong>utput directory，指定存放 HTML 报告的输出目录。<strong>此目录必须为空或不存在</strong>。</li>
</ul>
</li>
</ol>
<hr />
<h2>三、结果分析</h2>
<p>测试完成后，需要对结果数据进行详细解读，以评估系统性能。</p>
<h3><strong>聚合报告 (Aggregate Report) 结果解读</strong></h3>
<ul>
<li>
<p><strong><code>Label</code></strong>:是我们测试的请求的标签或名称。</p>
</li>
<li>
<p><strong><code># Samples</code> (样本数)</strong>: 总共完成了 <strong>200 次</strong>请求。</p>
</li>
<li>
<p><strong><code>Average</code> (平均响应时间)</strong>: 所有请求的<strong>平均响应时间是 1808 毫秒</strong> (约 1.81 秒)。这是评估服务处理速度最核心、最直观的指标。</p>
</li>
<li>
<p><strong><code>Median</code> (中位数)</strong>: 50% 的用户响应时间低于 <strong>1754 毫秒</strong>。比平均值更能抵抗极端值的影响。</p>
</li>
<li>
<p><strong><code>90% Line</code> (90百分位)</strong>: 90% 的请求响应时间都在 <strong>2060 毫秒</strong> (2.06 秒) 以内。</p>
</li>
<li>
<p><strong><code>95% Line</code> (95百分位)</strong>: 95% 的请求响应时间都在 <strong>2183 毫秒</strong> (2.18 秒) 以内。这是衡量服务稳定性的一个常用指标 (SLI/SLO)。</p>
</li>
<li>
<p><strong><code>99% Line</code> (99百分位)</strong>: 99% 的请求响应时间都在 <strong>2420 毫秒</strong> (2.42 秒) 以内，帮助我们了解最慢请求的情况。</p>
</li>
<li>
<p><strong><code>Min</code> / <code>Maximum</code> (最小/最大响应时间)</strong>: 最快的一次花费了 <strong>1.58 秒</strong>，最慢的一次花费了 <strong>2.83 秒</strong>。</p>
</li>
<li>
<p><strong><code>Error %</code> (错误率)</strong>: <strong>0.00%</strong> 是一个完美的指标！说明在当前并发压力下，服务非常稳定。</p>
</li>
<li>
<p><strong><code>Throughput</code> (吞吐量)</strong>: 服务器<strong>每秒钟能成功处理 1.1 个</strong>转换请求。这是衡量服务器处理能力的核心指标，通常也称为 QPS (Queries Per Second)。</p>
</li>
<li>
<p><strong><code>Received/Sent KB/sec</code></strong>: 每秒接收和发送的数据量。发送 (<code>Sent</code>) 远大于接收 (<code>Received</code>)，符合上传大文件的场景。</p>
</li>
</ul>
<h3><strong><code>jmeter_results.csv</code> 文件列名分析</strong></h3>
<p>CSV 文件记录了每一次请求的详细数据，便于进行更深入的分析。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>示例值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>responseCode</code></strong></td>
<td><code>200</code></td>
<td>HTTP 响应状态码。<code>200</code> 代表 <strong>OK (成功)</strong>。</td>
</tr>
<tr>
<td><strong><code>threadName</code></strong></td>
<td><code>word2pdf thread group 1-1</code></td>
<td>发出请求的具体<strong>虚拟用户（线程）的名称</strong>。</td>
</tr>
<tr>
<td><strong><code>dataType</code></strong></td>
<td><code>text</code></td>
<td>响应数据的类型。</td>
</tr>
<tr>
<td><strong><code>success</code></strong></td>
<td><code>true</code></td>
<td>请求是否成功。错误率 (<code>Error %</code>) 就是根据此列计算的。</td>
</tr>
<tr>
<td><strong><code>bytes</code></strong></td>
<td><code>740</code></td>
<td><strong>响应数据</strong>的大小（字节）。成功后只返回小段 JSON，所以值很小。</td>
</tr>
<tr>
<td><strong><code>sentBytes</code></strong></td>
<td><code>1691146</code></td>
<td><strong>发送数据</strong>的大小（字节）。此值很大，代表上传的 Word 文档大小。</td>
</tr>
<tr>
<td><strong><code>grpThreads</code></strong></td>
<td><code>2</code></td>
<td>请求发生时，其所在<strong>线程组</strong>内的活跃线程数。</td>
</tr>
<tr>
<td><strong><code>allThreads</code></strong></td>
<td><code>2</code></td>
<td>请求发生时，<strong>整个测试计划</strong>中的总活跃线程数。</td>
</tr>
<tr>
<td><strong><code>URL</code></strong></td>
<td><code>http://127.0.0.1:8080/...</code></td>
<td>请求的完整 URL 地址。</td>
</tr>
<tr>
<td><strong><code>Latency</code></strong></td>
<td><code>1792</code></td>
<td><strong>(重要指标)</strong> 从发出请求到接收到响应<strong>第一个字节</strong>的时间 (ms)，主要衡量<strong>服务器端处理时间</strong>。</td>
</tr>
<tr>
<td><strong><code>Connect</code></strong></td>
<td><code>0</code></td>
<td>建立 TCP 连接的时间 (ms)。通常只有首个请求耗时，后续复用连接，时间为 0。</td>
</tr>
</tbody></table><hr />
<h2>四、常见问题与技巧</h2>
<h3>Q: 点击绿色启动按钮时，应该选中哪个元件？</h3>
<p><strong>A: 您不需要选中任何特定的元件。</strong></p>
<p>JMeter 的启动按钮（绿色的三角箭头 <code>▶</code>）是针对<strong>整个测试计划 (Test Plan)</strong> 生效的。无论您当前在左侧的树状视图中选中了哪个元件，当您点击启动按钮时，JMeter 都会从最顶层的 <code>Test Plan</code> 开始，执行其中所有<strong>未被禁用</strong>的元件。</p>
<p><strong>如果不测试的元件，要禁用</strong></p>
<h3>关于启动和停止的额外提示</h3>
<ul>
<li><strong>启动 (Start)</strong>: 绿色的 <code>▶</code> 按钮。</li>
<li><strong>停止 (Stop)</strong>: 红色的 <code>■</code> 按钮。这会<strong>立即</strong>停止所有线程，可能会中断正在进行的请求。</li>
<li><strong>优雅地停止 (Shutdown)</strong>: <code>停止</code> 按钮旁边的那个灰色 <code>■</code> 按钮。这会允许当前正在执行的请求完成后再停止所有线程，是<strong>更推荐的停止方式</strong>。</li>
<li><strong>清除结果 (Clear All)</strong>: 工具栏上的扫帚图标 <code>🧹</code>。点击它会清除所有监听器（如 <code>聚合报告</code>、<code>查看结果树</code>）中已有的测试结果，方便您开始一次全新的测试。</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/24"/><category term="SOFTWARE"/><published>2025-07-24T10:33:00+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/23</id><title>关于Vibe coding 的思考</title><updated>2025-08-10T14:38:46.093072+00:00</updated><content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Vibe_coding">Vibe coding</a> 的时候一定要多观察 AI <strong>思考问题的思路</strong>和<strong>解决问题的过程</strong>，这才是重点，而不是 accept 的那个结果。
看 AI 是如何一步一步分析问题、实现需求、遇到问题解决问题。
仔细观察 AI 的输出结果去总结去记录，和 AI 对话会有大量的信息，从每一次的对话中总结经验，整理然后逐步内化成自己的能力
方法层面的东西远比结果更重要。
还有就是代码跑通了，还要多看看代码，去整理去归纳，这样才能有所收获，不然即使代码跑通了，也没什么用。我们要的不是真正的 VIbe，而是 knowledge。
最后的最后无脑 ask、 run、accept就是再浪费时间。</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/23"/><category term="THINK"/><published>2025-07-23T14:55:37+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/22</id><title>Mac 终端（Terminal）小 Tips</title><updated>2025-08-10T14:38:46.270934+00:00</updated><content type="html"><![CDATA[<ol>
<li>再终端中输入 <code>open .</code> 便可快速再 Finder 中打开当前文件</li>
<li>
</li>
</ol>
]]></content><link href="https://github.com/sunyuan686/blog/issues/22"/><category term="TOOL &amp;&amp; RESOURCE"/><published>2025-07-23T14:42:32+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/21</id><title>Warp 的窗口管理（分屏）</title><updated>2025-08-10T14:38:46.478022+00:00</updated><content type="html"><![CDATA[<p><a href="https://www.warp.dev/">Warp</a>  is the fastest way to build with multiple AI agents—from writing code to shipping it. The best overall coding and terminal agent.</p>
<p>以下快捷键都以Mac 为主，Window 烦请自行Google。
1.再选中的窗口向右添加窗口 : <code>Command + D</code></p>
<img width="1192" height="768" alt="Image" src="https://github.com/user-attachments/assets/91b4d4ad-b4bd-414c-9697-dbfa4cc33356" />
<p>2.再选中的窗口向下添加窗口 : <code>Command + Shift + D</code></p>
<img width="1192" height="768" alt="Image" src="https://github.com/user-attachments/assets/b9b57419-e29b-4163-9c1b-3c2ea355b10f" />
<p>3.如果你忘了快捷键 ，请记住 <code>Command + P</code> 打开搜索框输入 split，点击对应的选项即可实现分屏</p>
<img width="1192" height="768" alt="Image" src="https://github.com/user-attachments/assets/0d5c5bc5-5eac-4ed3-8375-7c45469909d3" />
]]></content><link href="https://github.com/sunyuan686/blog/issues/21"/><category term="SOFTWARE"/><published>2025-07-22T10:05:53+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/20</id><title>关于我的一切</title><updated>2025-08-10T14:38:46.635162+00:00</updated><content type="html"><![CDATA[<p>我是一个喜欢收集各种工具和资料的人，但是很少整理和分享，这好吗？这不好</p>
<p>1.<a href="https://blog.xixihaha.tech/issue-18/">我常使用的Mac 软件</a>
2.<a href="https://blog.xixihaha.tech/issue-19/">我关注了哪些人</a>
3.[我读过的书]
4.[我跑步听过的电台]
5.[我和我的家属]</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/20"/><category term="Top"/><published>2025-07-21T14:27:28+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/19</id><title>我关注了哪些人</title><updated>2025-08-10T14:38:46.836098+00:00</updated><content type="html"><![CDATA[<p>感谢所有人的输出，感谢互联网，感谢伟大的中国🇨🇳</p>
<ol>
<li><a href="https://blog.yihong0618.me/">yihong0618</a> : 喜欢王小波和跑步。</li>
<li><a href="https://www.owenyoung.com/">owen</a> : 沉浸式翻译作者，追求“注意力自由”。</li>
</ol>
<hr />
<ol start="2">
<li>如果我们有共同喜欢的人，欢迎一起交流 <a href="mailto:sunyuan608@gmail.com"> 📧 </a></li>
</ol>
]]></content><link href="https://github.com/sunyuan686/blog/issues/19"/><category term="TOOL &amp;&amp; RESOURCE"/><published>2025-07-21T14:16:06+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/18</id><title>我常使用的Mac 软件</title><updated>2025-08-10T14:38:47.011944+00:00</updated><content type="html"><![CDATA[<h2>一、 工具类</h2>
<p>🆓 免费</p>
<ol>
<li><a href="https://folivora.ai/keyboardcleantool">KeyboardCleanTool</a> : 一个清理Mac keyboard的小工具</li>
<li><a href="https://mos.caldis.me/">Mos</a> : 大大提升 Mac 使用鼠标体验的小工具</li>
<li><a href="https://mac-stats.com/">Stats</a> : 菜单栏系统监视器菜</li>
<li><a href="https://alt-tab-macos.netlify.app/">Alttab</a> : macOS上的 Windows alt-tab</li>
<li><a href="https://keepassxc.org/docs/KeePassXC_GettingStarted#_browser_integration">keeppassxc</a> :开源的本地密码管理器，支持浏览器快速填充（配合浏览器插件）同步需要配合 ICloud 或者 坚果云等同步工具。</li>
</ol>
<h2>二、 效率类</h2>
<ol>
<li><a href="https://www.raycast.com/">Ratcast</a> : Mac必装的聚焦搜索（快捷启动）工具，我装了这些插件:<a href="https://blog.xixihaha.tech/issue-17/">☞</a></li>
</ol>
<p>先写到这里，我会长期更新补充，如果你看到了，欢迎催我，也可以一起交流 <a href="mailto:sunyuan608@gmail.com"> 📧 </a></p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/18"/><category term="TOOL &amp;&amp; RESOURCE"/><published>2025-07-21T14:01:31+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/17</id><title>我装了这些 Raycast 插件</title><updated>2025-08-10T14:38:47.223752+00:00</updated><content type="html"><![CDATA[<p><a href="https://www.raycast.com/">Raycast</a> A collection of powerful productivity tools all within an extendable launcher. Fast, ergonomic and reliable.</p>
<p>1.<a href="https://github.com/raycast/extensions/blob/ad63c90763c3729655df44355eee95fc2c33c85e/extensions/messages/README.md">Messages</a>
如果你同时拥有 Mac 和 IPhone，且登录了同一个账号。光标聚焦输入框，全局任意地方，呼出 Raycast ，搜索 [Paste Latest OTP Code] ，便可以把你最新的验证码粘贴到光标聚焦的输入框。大大提升幸福感。
2. <a href="https://github.com/raycast/extensions/tree/f26a29453d8cf46efee0e9b2ea9eb6d9f096c069/extensions/single-disk-eject/">single-disk-eject</a>
随时随地，呼出 Raycast，输入 Eject Disk 即可弹出安装过的软件，解决安装后弹出磁盘的问题。</p>
<img width="750" height="474" alt="Image" src="https://github.com/user-attachments/assets/360a45ca-96e4-44df-8a4f-b545f8c925e5" />
<p>
<img width="920" height="436" alt="Image" src="https://github.com/user-attachments/assets/31470ba4-4ba6-4dc8-8e91-d7264d99b8ff" />
<ol start="4">
<li>等我有时间再整理补充，如果你看到了，欢迎催我 <a href="mailto:sunyuan608@gmail.com"> 📧 </a></li>
</ol>
]]></content><link href="https://github.com/sunyuan686/blog/issues/17"/><category term="TOOL &amp;&amp; RESOURCE"/><published>2025-07-21T13:55:06+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/16</id><title>都不会写字了！</title><updated>2025-08-10T14:38:47.478197+00:00</updated><content type="html"><![CDATA[<p>好久没有用笔写字了，今天要抄一些内容，发现好多字都不会写了，对很多笔画多的字都很陌生的感觉。
习惯了电子设备的输入，需要写字的场景太少了，打字的速度越来越快，离纸笔的距离却越来越远。
导致除了自己的名字，几乎很少去写字，慢慢的就越来越陌生了。
所以啊，还是要时不时去用笔写字，保持手感，不然过几年怕是都不会写字了！</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/16"/><category term="RANDOM"/><published>2025-07-18T06:17:59+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/15</id><title>代码风格好坏是要求自己的不是要求别人的</title><updated>2025-08-10T14:38:47.685645+00:00</updated><content type="html"><![CDATA[<p>代码风格好坏是要求自己的不是要求别人的！
<a href="https://blog.yihong0618.me/issue-318/">来源</a></p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/15"/><category term="THINK"/><published>2025-07-15T16:14:31+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/14</id><title>道德只能用来约束自己，不可以要求别人！</title><updated>2025-08-10T14:38:47.877188+00:00</updated><content type="html"><![CDATA[<p>道德只能用来约束自己，不可以要求别人！</p>
<p><img src="https://github.com/user-attachments/assets/bcce8ab2-ad79-402f-a7b6-593d35618142" alt="Image" /></p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/14"/><category term="THINK"/><published>2025-07-15T06:20:31+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/11</id><title>关于笔记体系的思考</title><updated>2025-08-10T14:38:48.062060+00:00</updated><content type="html"><![CDATA[<p>标签体系</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/11"/><category term="TODO"/><published>2025-07-12T03:48:12+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/10</id><title>装修该博客</title><updated>2025-08-10T14:38:48.252881+00:00</updated><content type="html"><![CDATA[<ul>
<li>
<p><input disabled="" type="checkbox"> 调整样式</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 增加搜索功能（搜索功能不简单需要再研究）</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 增加查看所有标签功能</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 增加归档功能 按照月份 </p>
</li>
<li>
<p><input disabled="" type="checkbox"> 按照标签</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 增加统计人数，总计文章数量，用户数量，标签数量等</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 添加icon</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 支持暗色模式</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 不同的主题区别挺大的。无法完整兼容自己想要的全部功能，可能得自己去二开一些主题了。现在使用过的主题有 even 和apollo。even对 github issue 有单独的适配，但是可配置项也更少一些。</p>
</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/10"/><category term="TODO"/><published>2025-07-09T16:14:54+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/9</id><title>GitHub Page 如何使用自定义域名</title><updated>2025-08-10T14:38:48.509911+00:00</updated><content type="html"><![CDATA[<p>null</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/9"/><category term="TODO"/><published>2025-07-09T16:11:35+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/8</id><title>如何部署该博客！</title><updated>2025-08-10T14:38:48.675698+00:00</updated><content type="html"><![CDATA[<p>null</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/8"/><category term="TODO"/><published>2025-07-09T16:10:17+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/6</id><title>About me</title><updated>2025-08-10T14:38:48.860635+00:00</updated><content type="html"><![CDATA[<p>Runs for fun. Not fast.</p>
<p>No life .Coding is passion.</p>
<p>Vim & terminal lover.</p>
<p>Obsessive about efficiency and high-performance code.</p>
<p>Pursuing a pure keyboard workflow（%10 😅 ）.</p>
<p>: wq</p>]]></content><link href="https://github.com/sunyuan686/blog/issues/6"/><category term="About"/><published>2025-07-09T13:20:23+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/4</id><title>AI 太会安慰人了，像一个贴心的好老师，给你信心给你安慰</title><updated>2025-08-10T14:38:49.046453+00:00</updated><content type="html"><![CDATA[<p>&lt; 我是一个废物。学不会算法，学习能力差，一道归并排序半天没学会，我该怎么办。</p>
<p>看到你这么说，我感到非常难过，但请你 一定、一定不要这样称呼自己。
你不是废物。你只是一个在学习过程中遇到了困难，感到极度挫败的学生。这种感觉，几乎每一个学习编程和算法的人都经历过，真的，我向你保证。
“一道归并排序半天没学会” 这件事，绝对不能定义你这个人，更不能说明你学习能力差。让我为你拆解一下这个问题，希望能帮助你走出这个困境。
首先，我们来谈谈“归并排序”这件事
归并排序（Merge Sort）对于初学者来说，确实是一个门槛。原因如下：</p>
<ul>
<li>抽象性强：它不像冒泡排序那样直观。它用到了“分治”（Divide and Conquer）的思想，这本身就是一种高级的解决问题的策略。</li>
<li>依赖递归：它的核心实现是递归函数。人类的大脑天生就不太习惯思考递归，很容易会“绕进去”，搞不清楚函数是怎么一层层调用又一层层返回的。</li>
<li>细节多：合并（Merge）两个有序数组的步骤，需要处理好数组的边界、指针的移动，很容易出错。
所以，半天没学会归并排序，不是你的问题，而是这个知识点本身就具备挑战性。把一个很难的问题归咎于自己“笨”，这是最让人沮-丧且无效的。
接下来，我们该怎么办？
忘掉“我是废物”这个念头，我们把它换成一个实际的问题：“我该如何有效地学会归并排序？”
试试下面的步骤，一步一步来，别着急：
第1步：放下代码，拿起纸笔（或扑克牌）</li>
<li>绝对不要一开始就死磕代码！</li>
<li>找8张扑克牌或者剪8张小纸片，写上不同的数字。亲手模拟一遍归并排序的过程。</li>
<li>“分”的过程：把8张牌分成两堆4张的，再把每堆4张的分成两堆2张的，最后分成8个独立的牌。这个过程很简单，对吧？</li>
<li>
“合”的过程（关键！）：<ul>
<li>先拿起两张单独的牌，把它们按顺序排好，合并成一个2张的有序牌堆。</li>
<li>现在你有4个2张的有序牌堆了。拿起其中两个（比如 [3, 7] 和 [2, 5]），把它们合并成一个4张的有序牌堆 [2, 3, 5, 7]。亲手模拟这个合并的过程，看看你的手指是怎么比较两堆牌顶的牌，然后把小的拿出来的。</li>
<li>最后，把两个4张的有序牌堆，用同样的方法，合并成最终的8张有序牌堆。
当你能用手顺利地把扑克牌排序一遍后，你其实已经理解了归并排序80%的精髓了。
第2步：看可视化动画
去B站或者YouTube搜索“归并排序 可视化” (Merge Sort Visualization)。看动画是如何一步步分裂数组，又一步步合并的。结合你刚才手动操作的经验，你会豁然开朗。
第3步：重新理解代码
现在，带着“原来是这么回事”的理解，再去看代码。你会发现代码的逻辑和你手动操作是完全对应的：</li>
</ul>
</li>
<li>递归的终止条件 if (left &gt;= right) 就是你把牌分到只剩一张的时候。</li>
<li>merge_sort(arr, left, mid) 和 merge_sort(arr, mid + 1, right) 就是在“分”牌堆。</li>
<li>merge(arr, left, mid, right) 函数，就是你手动合并两个有序牌堆的过程。
第4步：调试和模仿</li>
<li>把代码复制下来，在关键步骤加上打印语句（print），比如在 merge 函数里打印每次合并前的两个子数组，以及合并后的数组。运行一下，看看程序的输出和你手动模拟的是不是一样。</li>
<li>理解之后，尝试自己默写一遍。写不出来没关系，再看一遍，再默写。重复这个过程。
最后，关于“学习能力差”这个更大的问题
这很可能是一个错误的结论。学习不是一蹴而就的，它更像是在健身。</li>
<li>你不是举不起100公斤，你只是需要从10公斤开始练起。 归并排序可能就是那个50公斤的杠铃，在你只练过几次10公斤的时候，举不起来太正常了。你需要的是找到更基础的练习（比如彻底搞懂数组、循环、简单递归），而不是责怪自己力气小。</li>
<li>感到痛苦，是大脑在成长的信号。 当你觉得一件事很难、很绕、很痛苦的时候，恰恰是你的大脑在被迫建立新的神经连接。这是在“上难度”，是进步的必经之路。轻松舒适区里是学不到新东西的。</li>
<li>停止比较，关注自身。 你可能看到别人很快就学会了，但你不知道他们背后付出了多少努力，或者在学这个之前已经有了多少你看不到的知识积累。你的节奏只属于你，只要今天的你比昨天的你多理解了一点点，就是巨大的胜利。
请记住：
你遇到的困难，是所有学习者的共同困难。你感到的挫败，是所有攀登者的共同感受。
你不是废物，你只是一个在攀登一座有点陡峭的山峰的学习者。暂时卡住，不代表你登不上去。调整一下装备（学习方法），喘口气（休息一下），你完全可以继续前行。
给自己一点时间和耐心。如果今天学不会，就睡一觉，让大脑在后台自己处理一下信息，明天可能就会有新的理解。加油！你远比你想象的要强大。</li>
</ul>
]]></content><link href="https://github.com/sunyuan686/blog/issues/4"/><category term="THINK"/><published>2025-07-06T16:15:16+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/3</id><title>去输出去分享！</title><updated>2025-08-10T14:38:49.250384+00:00</updated><content type="html"><![CDATA[<p>要疯狂输入然后输出，要形成闭环。
用输出倒逼自己，驱动去学习整理理解记忆。不然太容易忘了。
还有就是干啥事情不要战线拉太长，不然就会学了后面的忘了前面的，太痛苦了。
Respect </p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/3"/><category term="THINK"/><published>2025-06-23T16:22:01+00:00</published></entry><entry><id>https://github.com/sunyuan686/blog/issues/2</id><title>学计算机一定要折腾，不怕麻烦。</title><updated>2025-08-10T14:38:49.418286+00:00</updated><content type="html"><![CDATA[<p>出来混，最重要的是出来。
博客一直在纠结用什么工具，用什么主题，框架怎么搭，却忽略了最重要的是内容啊。
看到了好多大佬再输出，也想整一个，一直懒得折腾，迟迟没有去行动，几年了最终什么都没有。
所以说学计算机，一定要多折腾。
从折腾从总结经验，从折腾中学习，去折腾，去感受，去寻找自己愿意折腾并真正喜欢的事情。</p>
]]></content><link href="https://github.com/sunyuan686/blog/issues/2"/><category term="THINK"/><published>2025-06-22T16:16:13+00:00</published></entry></feed>